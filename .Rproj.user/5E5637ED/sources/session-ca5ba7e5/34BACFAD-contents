---
title: "fsblf_1208"
author: "Ziyu Liu"
date: "2024-12-08"
output: pdf_document
---

```{r}
library(Matrix)
library(Rlab)
library(tidyr)
library(MASS)
library(coda)
library(MCMCpack)
library(matrixcalc)
setwd("/Users/ziyuliu/Desktop/parm_res_1108")
slurm_arrayid = 1
train_size = 200
Xtrain_str = paste0("Xtrain_", slurm_arrayid, "_n_", train_size, "_results.RData")
Ztrain_str = paste0("Ztrain_", slurm_arrayid, "_n_", train_size, "_results.RData")
Z_train_no_e =  paste0("Ztrain_no_e_", slurm_arrayid, "_n_", train_size, "_results.RData")
load(Z_train_no_e)
load(Xtrain_str)
load(Ztrain_str)
load("basis_x_32.RData")
load("basis_z_32.RData")
load(paste0("ll_", slurm_arrayid, "_", "n_", train_size,"_results.RData"))
image_size = 32
image_dim = 2
latent_nmb = 5
pred_nmb = 5
vox_nmb = image_size^image_dim
bandwidth_gen = 0.001
bandwidth = bandwidth_gen * (image_size - 1) * sqrt(2)
basis_dist = 4
basis_nmb = nrow(basis_X)
test_size = 100

set.seed(1)
```

```{r}
weighted_pred <- function(dat, gamma_p, pred_nmb) {
  sub_nmb <- nrow(dat)
  vox_nmb <- ncol(dat) / pred_nmb
  reshaped_dat <- array(dat, dim = c(sub_nmb, vox_nmb, pred_nmb))
  x_tilde <- apply(reshaped_dat, c(1, 2), function(slice) sum(slice * gamma_p))
  return(x_tilde)
}


Omega_Z_gen = function(Omega, X_tilde, basis_X, basis_Z) {
  tcrossprod(X_tilde, basis_X) %*% Omega %*% basis_Z 
}

Z_star_no_iter = function(Z, basis_Z) {
  bz2 = tcrossprod(basis_Z)
  bz_Z_t = tcrossprod(basis_Z, Z)
  Z_bz = tcrossprod(Z, basis_Z)
  if (!is.positive.definite(bz2)) {
    print("check bz")
    bz2 = bz2 + diag(1e-6, nrow(bz2))
  }
  R_bz = chol(bz2)
  Z_star = forwardsolve(R_bz, bz_Z_t, upper.tri = TRUE, transpose = TRUE)
  Z_star = backsolve(R_bz, Z_star)
  Z_star = t(Z_star)
  chol_solve_bz2 = backsolve(R_bz, diag(nrow(bz2)))
  return(list(bz2 = bz2, R_bz = R_bz, Z_star = Z_star, chol_solve_bz2 = chol_solve_bz2, Z_bz = Z_bz))
}

Z_star_gen = function(Z_bz, X_tilde, basis_X, Z_star_b) {
  bx_x_tilde = tcrossprod(basis_X, X_tilde)
  bx_x_x_bx = tcrossprod(bx_x_tilde)
  if (!is.positive.definite(bx_x_x_bx)) {
    print("check bxxb")
    bx_x_x_bx = bx_x_x_bx + diag(1e-6, nrow(bx_x_tilde))
  }
  Z_star_iter = bx_x_tilde %*% Z_star_b
  R_bxx = chol(bx_x_x_bx)
  Z_star_iter = forwardsolve(R_bxx, Z_star_iter, upper.tri = TRUE, transpose = TRUE)
  Z_star_iter = backsolve(R_bxx, Z_star_iter)
  chol_solve_bxx = backsolve(R_bxx, diag(nrow(R_bxx)))
  return(list(Z_star_iter = Z_star_iter, bx_x_x_bx = bx_x_x_bx, R_bxx = R_bxx, chol_solve_bxx = chol_solve_bxx))
}


sample_matrix_normal <- function(n = 10,p=5, M=NULL, U=NULL, V=NULL, solved_Ru, solved_Rv){
  if(!is.null(M)){
    n <- nrow(M)
    p <- ncol(M)
  } 
  Ru = solved_Ru
  Rv = solved_Rv
  Z = matrix(rnorm(n*p),nrow=n,ncol=p)
  Y <- M + tcrossprod((Ru %*% Z), Rv)
  return(Y)
}

sigma_e_fcp_dist = function(R_bxx, R_bz, Omega_iter, Z_star_iter, a_iter, g) {
  # Dimensions of the matrices
  M_x = nrow(R_bxx)
  M_z = nrow(R_bz)
  
  # Pre-compute constants
  sqrt_g = g^(-1/2)
  shape_val = 0.5 + M_x * M_z
  
  # Compute the difference and individual terms
  diff_val = Z_star_iter - Omega_iter
  st = sqrt_g * tcrossprod(R_bxx %*% Omega_iter, R_bz)
  mt = tcrossprod(R_bxx %*% diff_val, R_bz)
  
  # Calculate trace contributions
  trace_part = 0.5 * sum(st^2)
  trace_result = 0.5 * sum(mt^2) + trace_part
  
  # Scale parameter for the inverse gamma
  scale_val = (1 / a_iter) + trace_result
  
  # Return square root of sampled value
  sqrt(rinvgamma(1, shape_val, scale_val))
}

sigma_e_fcp_dist_12 = function(X_tilde, Omega_iter, basis_Z, Z, basis_X, g, a_iter) {
  x_omega_basis = X_tilde %*% crossprod(basis_X, Omega_iter) %*% basis_Z
  Q_val = Z - x_omega_basis
  T_val = g^(-1/2) * x_omega_basis
  trace_res = 0.5 * (sum(Q_val^2) + sum(T_val^2))
  scale_val = (1 / a_iter) + trace_res
  vz = ncol(Z)
  n = nrow(Z)
  Mz = nrow(basis_Z)
  Mx = nrow(basis_X)
  shape_val = 0.5 * (vz * n) + 0.5 * (Mz * Mx) + 0.5
  sqrt(rinvgamma(1, shape_val, scale_val))
}

a_fcp_dist = function(A, sigma_e_iter) {
  sigma_m_2 = sigma_e_iter^(-2)
  scale_val = A^(-2) + sigma_m_2
  rinvgamma(1, 1, scale_val)
}

log_lik_func = function(Z_val, X_tilde, basis_X, Omega, basis_Z, sigma_e) {
  mu_val = tcrossprod(X_tilde, basis_X) %*% Omega %*% basis_Z
  mu_list = c(mu_val)
  Z_list = c(Z_val)
  dnorm_sum = sum(dnorm(Z_list, mu_list, sigma_e, log = TRUE))
  return(dnorm_sum)
}

MSE = function(Z_true, Z_est) {
  return(mean((Z_true - Z_est)^2))
}

# Sample parameters 
parm_gen_qr = function(X, basis_X, Omega_initial, basis_Z, Z, sigma_e_initial,  a_initial,n_iter, n_burn, gamma, pred_nmb, latent_nmb, A, g = 1,fix_sigma_e = FALSE, fix_Omega = FALSE) {
  vox_nmb_z = ncol(Z)
  # Number of basis functions
  basis_Z_nmb = nrow(basis_Z)
  basis_X_nmb = nrow(basis_X)
  g_val = g/(1 + g)
  Z_star_no_iter_list = Z_star_no_iter(Z, basis_Z)
  bz2 = Z_star_no_iter_list$bz2
  R_bz = Z_star_no_iter_list$R_bz
  Z_star_b = Z_star_no_iter_list$Z_star
  chol_solve_bz2 = Z_star_no_iter_list$chol_solve_bz2
  # This will be used in the sigma_e sampling
  Z_bz = Z_star_no_iter_list$Z_bz
  # This part will be iteratively changed if the gamma p sampled
  X_tilde = weighted_pred(X, gamma, pred_nmb)
  Z_star_list = Z_star_gen(Z_bz, X_tilde, basis_X, Z_star_b)
  Z_star_iter = Z_star_list$Z_star_iter
  bx_x_x_bx = Z_star_list$bx_x_x_bx
  R_bxx = Z_star_list$R_bxx
  bx_x_Z_bz = Z_star_list$bx_x_Z_bz
  chol_solve_bxx = Z_star_list$chol_solve_bxx
  res_list = list()
  g_val_Z_star = g_val * Z_star_iter
  kro_value = kronecker(bz2, bx_x_x_bx)
  for (i in 1:length(sigma_e_initial)) {
    Omega_iter = Omega_initial[, , i]
    sigma_e_iter = sigma_e_initial[i]
    a_iter = a_initial[i]
    Omega_array = array(data = NA, dim = c(nrow(Omega_iter), ncol(Omega_iter), n_iter - n_burn))
    Omega_sum = matrix(0, nrow = nrow(Omega_iter), ncol = ncol(Omega_iter))
    # Store iterated sigma_e
    sigma_e_sum = 0
    sigma_e = c()
    # Log-likelihood list
    ll_l = c()
    # ll_l = c(ll_l, log_lik_func(Z, X_tilde, basis_X, Omega_iter, basis_Z, sigma_e_iter))
    a_list = c()
    for (n in 1:n_iter) {
      if (!fix_sigma_e) {
        a_iter = a_fcp_dist(A, sigma_e_iter)
        sigma_e_iter = sigma_e_fcp_dist(R_bxx, R_bz, Omega_iter, Z_star_iter, a_iter, g)
      }
      if (!fix_Omega) {
        Omega_iter = sample_matrix_normal(M = g_val_Z_star, solved_Ru = chol_solve_bxx, solved_Rv = sigma_e_iter * sqrt(g_val) * chol_solve_bz2)
      }
      iter_ll = log_lik_func(Z, X_tilde, basis_X, Omega_iter, basis_Z, sigma_e_iter)
      ll_l = c(ll_l, iter_ll)
      if (n > n_burn) {
        Omega_sum = Omega_sum + Omega_iter
        Omega_array[,,(n - n_burn)] = Omega_iter
        sigma_e_sum = sigma_e_sum + sigma_e_iter
        sigma_e = c(sigma_e, sigma_e_iter)
        a_list = c(a_list, a_iter)
      }
    }
    last_list = list(last_Omega = Omega_iter, last_sigma_e = sigma_e_iter)
    res_list[[i]] = list(sigma_e_sum = sigma_e_sum, Omega_sum = Omega_sum, Omega_array = Omega_array,sigma_e = sigma_e, ll_l = ll_l, last_list = last_list, chol_solve_bxx = chol_solve_bxx, chol_solve_bz2 = chol_solve_bz2, a_list = a_list)
  }
  return(res_list)
}
parm_gen_qr_12 = function(X, basis_X, Omega_initial, basis_Z, Z, sigma_e_initial,  a_initial,n_iter, n_burn, gamma, pred_nmb, latent_nmb, A, g = 1,fix_sigma_e = FALSE, fix_Omega = FALSE) {
  vox_nmb_z = ncol(Z)
  # Number of basis functions
  basis_Z_nmb = nrow(basis_Z)
  basis_X_nmb = nrow(basis_X)
  g_val = g/(1 + g)
  Z_star_no_iter_list = Z_star_no_iter(Z, basis_Z)
  bz2 = Z_star_no_iter_list$bz2
  R_bz = Z_star_no_iter_list$R_bz
  Z_star_b = Z_star_no_iter_list$Z_star
  chol_solve_bz2 = Z_star_no_iter_list$chol_solve_bz2
  # This will be used in the sigma_e sampling
  Z_bz = Z_star_no_iter_list$Z_bz
  # This part will be iteratively changed if the gamma p sampled
  X_tilde = weighted_pred(X, gamma, pred_nmb)
  Z_star_list = Z_star_gen(Z_bz, X_tilde, basis_X, Z_star_b)
  Z_star_iter = Z_star_list$Z_star_iter
  bx_x_x_bx = Z_star_list$bx_x_x_bx
  R_bxx = Z_star_list$R_bxx
  bx_x_Z_bz = Z_star_list$bx_x_Z_bz
  chol_solve_bxx = Z_star_list$chol_solve_bxx
  res_list = list()
  g_val_Z_star = g_val * Z_star_iter
  kro_value = kronecker(bz2, bx_x_x_bx)
  for (i in 1:length(sigma_e_initial)) {
    Omega_iter = Omega_initial[, , i]
    sigma_e_iter = sigma_e_initial[i]
    a_iter = a_initial[i]
    Omega_array = array(data = NA, dim = c(nrow(Omega_iter), ncol(Omega_iter), n_iter - n_burn))
    Omega_sum = matrix(0, nrow = nrow(Omega_iter), ncol = ncol(Omega_iter))
    # Store iterated sigma_e
    sigma_e_sum = 0
    sigma_e = c()
    # Log-likelihood list
    ll_l = c()
    # ll_l = c(ll_l, log_lik_func(Z, X_tilde, basis_X, Omega_iter, basis_Z, sigma_e_iter))
    a_list = c()
    for (n in 1:n_iter) {
      if (!fix_sigma_e) {
        a_iter = a_fcp_dist(A, sigma_e_iter)
        sigma_e_iter = sigma_e_fcp_dist_12(X_tilde, Omega_iter, basis_Z, Z, basis_X, g, a_iter)
      }
      if (!fix_Omega) {
        Omega_iter = sample_matrix_normal(M = g_val_Z_star, solved_Ru = chol_solve_bxx, solved_Rv = sigma_e_iter * sqrt(g_val) * chol_solve_bz2)
      }
      iter_ll = log_lik_func(Z, X_tilde, basis_X, Omega_iter, basis_Z, sigma_e_iter)
      ll_l = c(ll_l, iter_ll)
      if (n > n_burn) {
        Omega_sum = Omega_sum + Omega_iter
        Omega_array[,,(n - n_burn)] = Omega_iter
        sigma_e_sum = sigma_e_sum + sigma_e_iter
        sigma_e = c(sigma_e, sigma_e_iter)
        a_list = c(a_list, a_iter)
      }
    }
    last_list = list(last_Omega = Omega_iter, last_sigma_e = sigma_e_iter)
    res_list[[i]] = list(sigma_e_sum = sigma_e_sum, Omega_sum = Omega_sum, Omega_array = Omega_array,sigma_e = sigma_e, ll_l = ll_l, last_list = last_list, chol_solve_bxx = chol_solve_bxx, chol_solve_bz2 = chol_solve_bz2, a_list = a_list)
  }
  return(res_list)
}
```

```{r}
true_sigma_e = 0.5
gamma_1 = rep(1, pred_nmb / 2)
gamma_0 = rep(0, pred_nmb - length(gamma_1))
true_gamma_p = c(gamma_1, gamma_0)
true_Omega_start = matrix(rnorm(basis_nmb * basis_nmb), nrow = basis_nmb, ncol = basis_nmb)
qr_decomp = qr(true_Omega_start)
alpha_t = qr.Q(qr_decomp)[,1:latent_nmb]
Lambda_t = qr.R(qr_decomp)[1:latent_nmb, ]
true_alpha = t(alpha_t)
true_Lambda = t(Lambda_t)
true_Omega = alpha_t %*% Lambda_t
```

```{r}
g_lower = 0.999/0.001
```

```{r}
g_val_list = c(1e3, 1e4, 1e5, 1e6)
```

```{r, cache = TRUE}
# Update sigma_e given Omega at the true value
sigma_e_initial1 = 1.5
sigma_e_initial2 = 1
sigma_e_initial = c(sigma_e_initial1, sigma_e_initial2, true_sigma_e)
true_Omega_initial = array(c(true_Omega, true_Omega, true_Omega), dim = c(nrow(basis_X), nrow(basis_Z), 3))
ll_l_true_omega1 = c()
sigma_e_true_omega1 = c()
ll_l_true_omega2 = c()
sigma_e_true_omega2 = c()
ll_l_true_omega3 = c()
sigma_e_true_omega3 = c()
n_iter = 10000
n_burn = 7500
a_initial = c(1, 1, 1)
A = 1
for (g_hyper in g_val_list) {
  parm_res_fix_Omega = parm_gen_qr_12(X_trn, basis_X, true_Omega_initial, basis_Z, Z_trn, sigma_e_initial, a_initial,n_iter, n_burn, true_gamma_p, pred_nmb, latent_nmb, A, g = g_hyper, fix_Omega = TRUE)
  ll_l_true_omega1 = rbind(ll_l_true_omega1, parm_res_fix_Omega[[1]]$ll_l)
  ll_l_true_omega2 = rbind(ll_l_true_omega2, parm_res_fix_Omega[[2]]$ll_l)
  ll_l_true_omega3 = rbind(ll_l_true_omega3, parm_res_fix_Omega[[3]]$ll_l)
  sigma_e_true_omega1 = rbind(sigma_e_true_omega1, parm_res_fix_Omega[[1]]$sigma_e)
  sigma_e_true_omega2 = rbind(sigma_e_true_omega2, parm_res_fix_Omega[[2]]$sigma_e)
  sigma_e_true_omega3 = rbind(sigma_e_true_omega3, parm_res_fix_Omega[[3]]$sigma_e)
}
```



The true log likelihood equals to -148820.5

```{r}
for (i in 1:length(g_val_list)) {
  g_val_i = g_val_list[i]
  traceplot_list = mcmc.list(as.mcmc(ll_l_true_omega1[i, (n_burn + 1):n_iter]), as.mcmc(ll_l_true_omega2[i, (n_burn + 1):n_iter]), as.mcmc(ll_l_true_omega3[i, (n_burn + 1):n_iter]))
  par(mar = c(2, 2, 2, 2))
  if (i == 1) {
    traceplot(traceplot_list, main = paste("Log-likelihood traceplot with true Omega g =",g_val_i),  ylim = c( min(ll_l_true_omega1[i, (n_burn + 1):n_iter]), true_ll_trn))
    # print(true_ll_trn)
    # max(traceplot_list[[1]])
    abline(h = true_ll_trn, col = "orange")
  } else {
    traceplot(traceplot_list, main = paste("Log-likelihood traceplot with true Omega g =", g_val_i))
    abline(h = true_ll_trn, col = "orange")
  }
  
  legend("right", legend=c("sigma = 1.5", "sigma = 1", "sigma = 0.5"),  
         fill = c("black","red", "green"))
  sigma_traceplot_list = mcmc.list(as.mcmc(sigma_e_true_omega1[i, ]), as.mcmc(sigma_e_true_omega2[i, ]), as.mcmc(sigma_e_true_omega3[i, ]))
  traceplot(sigma_traceplot_list, main = paste("sigma traceplot with true Omega g =", g_val_i))
  abline(h = true_sigma_e, col = "orange")
  legend("bottomright", legend=c("sigma = 1.5", "sigma = 1", "sigma = 0.5"),  
         fill = c("black","red", "green"))
}
```

```{r, cache = TRUE}
Z_star_no_iter_list = Z_star_no_iter(Z_trn, basis_Z)
bz2 = Z_star_no_iter_list$bz2
R_bz = Z_star_no_iter_list$R_bz
Z_star_b = Z_star_no_iter_list$Z_star
# This part will be iteratively changed if the gamma p sampled
X_tilde = weighted_pred(X_trn, true_gamma_p, pred_nmb)
Z_star_list = Z_star_gen(Z_bz, X_tilde, basis_X, Z_star_b)
Omega_hat = Z_star_list$Z_star_iter
Omega_hat_initial = array(c(Omega_hat, Omega_hat, Omega_hat), dim = c(nrow(basis_X), nrow(basis_Z), 3))
ll_l_omega_hat1 = c()
sigma_e_omega_hat1 = c()
ll_l_omega_hat2 = c()
sigma_e_omega_hat2 = c()
ll_l_omega_hat3 = c()
sigma_e_omega_hat3 = c()
n_iter = 10000
n_burn = 7500
for (g_hyper in g_val_list) {
  parm_res_fix_Omega_hat = parm_gen_qr_12(X_trn, basis_X, Omega_hat_initial, basis_Z, Z_trn, sigma_e_initial, a_initial,n_iter, n_burn, true_gamma_p, pred_nmb, latent_nmb, A, g = g_hyper, fix_Omega = TRUE)
  ll_l_omega_hat1 = rbind(ll_l_omega_hat1, parm_res_fix_Omega_hat[[1]]$ll_l)
  ll_l_omega_hat2 = rbind(ll_l_omega_hat2, parm_res_fix_Omega_hat[[2]]$ll_l)
  ll_l_omega_hat3 = rbind(ll_l_omega_hat3, parm_res_fix_Omega_hat[[3]]$ll_l)
  sigma_e_omega_hat1 = rbind(sigma_e_omega_hat1, parm_res_fix_Omega_hat[[1]]$sigma_e)
  sigma_e_omega_hat2 = rbind(sigma_e_omega_hat2, parm_res_fix_Omega_hat[[2]]$sigma_e)
  sigma_e_omega_hat3 = rbind(sigma_e_omega_hat3, parm_res_fix_Omega_hat[[3]]$sigma_e)
}
```

```{r}
for (i in 1:length(g_val_list)) {
  g_val_i = g_val_list[i]
  traceplot_list = mcmc.list(as.mcmc(ll_l_omega_hat1[i, (n_burn + 1):n_iter]), as.mcmc(ll_l_omega_hat2[i, (n_burn + 1):n_iter]), as.mcmc(ll_l_omega_hat3[i, (n_burn + 1):n_iter]))
  par(mar = c(2, 2, 2, 2))
  if (i == 1) {
    traceplot(traceplot_list, main = paste("Log-likelihood traceplot with Omega hat g =", g_val_i), ylim = c(true_ll_trn, max(ll_l_omega_hat1[i, (n_burn + 1):n_iter])))
    abline(h = true_ll_trn, col = "orange")
  } else {
    traceplot(traceplot_list, main = paste("Log-likelihood traceplot with Omega hat g =", g_val_i))
    abline(h = true_ll_trn, col = "orange")
  }
  
  legend("right", legend=c("sigma = 1.5", "sigma = 1", "sigma = 0.5"),  
         fill = c("black","red", "green"))
  
  sigma_traceplot_list = mcmc.list(as.mcmc(sigma_e_omega_hat1[i, ]), as.mcmc(sigma_e_omega_hat2[i, ]), as.mcmc(sigma_e_omega_hat3[i, ]))
  traceplot(sigma_traceplot_list, main = paste("sigma traceplot with Omega hat g =", g_val_i))
  abline(h = true_sigma_e, col = "orange")
  legend("bottomright", legend=c("sigma = 1.5", "sigma = 1", "sigma = 0.5"),  
         fill = c("black","red", "green"))
}
```

```{r}
for (i in 1:length(g_val_list)) {
  g_val_i = g_val_list[i]
  traceplot_list = mcmc.list(as.mcmc(ll_l_omega_hat1[i, ]), as.mcmc(ll_l_omega_hat2[i, ]), as.mcmc(ll_l_omega_hat3[i, ]))
  par(mar = c(2, 2, 2, 2))
  if (i == 1) {
    traceplot(traceplot_list, main = paste("Log-likelihood traceplot with Omega hat g =", g_val_i), ylim = c(true_ll_trn, max(ll_l_omega_hat1[i, ])))
    abline(h = true_ll_trn, col = "orange")
  } else {
    traceplot(traceplot_list, main = paste("Log-likelihood traceplot with Omega hat g =", g_val_i))
    abline(h = true_ll_trn, col = "orange")
  }
  
  legend("right", legend=c("sigma = 1.5", "sigma = 1", "sigma = 0.5"),  
         fill = c("black","red", "green"))
}
```


```{r}
Z_hat = Omega_Z_gen(Omega_hat, X_tilde, basis_X, basis_Z)
sigma_e_hat = sqrt(var(c(Z_trn) - c(Z_hat)))
```

```{r, cache = TRUE}
Omega_initial1 = matrix(rnorm(nrow(basis_Z) * nrow(basis_X)), nrow = nrow(basis_X), ncol = nrow(basis_Z))
Omega_initial2 = matrix(rnorm(nrow(basis_Z) * nrow(basis_X), 0, 10), nrow = nrow(basis_X), ncol = nrow(basis_Z))
Omega_initial3 = true_Omega
Omega_initial = array(c(Omega_initial1, Omega_initial2, Omega_initial3), dim = c(nrow(basis_X), nrow(basis_Z), 3))
ll_l_sigma_hat1 = c()
Omega_11_sigma_hat1 = c()
Omega_22_sigma_hat1 = c()
Omega_33_sigma_hat1 = c()
ll_l_sigma_hat2 = c()
Omega_11_sigma_hat2 = c()
Omega_22_sigma_hat2 = c()
Omega_33_sigma_hat2 = c()
ll_l_sigma_hat3 = c()
Omega_11_sigma_hat3 = c()
Omega_22_sigma_hat3 = c()
Omega_33_sigma_hat3 = c()
sigma_e_hat_initial = c(sigma_e_hat, sigma_e_hat, sigma_e_hat)
n_iter = 10000
n_burn = 7500
for (g_hyper in g_val_list) {
  parm_res_fix_sigma_hat = parm_gen_qr_12(X_trn, basis_X, Omega_initial, basis_Z, Z_trn, sigma_e_hat_initial, a_initial,n_iter, n_burn, true_gamma_p, pred_nmb, latent_nmb, A, g = g_hyper, fix_sigma_e = TRUE)
  ll_l_sigma_hat1 = rbind(ll_l_sigma_hat1, parm_res_fix_sigma_hat[[1]]$ll_l)
  ll_l_sigma_hat2 = rbind(ll_l_sigma_hat2, parm_res_fix_sigma_hat[[2]]$ll_l)
  ll_l_sigma_hat3 = rbind(ll_l_sigma_hat3, parm_res_fix_sigma_hat[[3]]$ll_l)
  
  Omega_11_sigma_hat1 = rbind(Omega_11_sigma_hat1, parm_res_fix_sigma_hat[[1]]$Omega_array[1, 1, ])
  Omega_22_sigma_hat1 = rbind(Omega_22_sigma_hat1, parm_res_fix_sigma_hat[[1]]$Omega_array[2, 2, ])
  Omega_33_sigma_hat1 = rbind(Omega_33_sigma_hat1, parm_res_fix_sigma_hat[[1]]$Omega_array[3, 3, ])
  
  Omega_11_sigma_hat2 = rbind(Omega_11_sigma_hat2, parm_res_fix_sigma_hat[[2]]$Omega_array[1, 1, ])
  Omega_22_sigma_hat2 = rbind(Omega_22_sigma_hat2, parm_res_fix_sigma_hat[[2]]$Omega_array[2, 2, ])
  Omega_33_sigma_hat2 = rbind(Omega_33_sigma_hat2, parm_res_fix_sigma_hat[[2]]$Omega_array[3, 3, ])
  
  Omega_11_sigma_hat3 = rbind(Omega_11_sigma_hat3, parm_res_fix_sigma_hat[[3]]$Omega_array[1, 1, ])
  Omega_22_sigma_hat3 = rbind(Omega_22_sigma_hat3, parm_res_fix_sigma_hat[[3]]$Omega_array[2, 2, ])
  Omega_33_sigma_hat3 = rbind(Omega_33_sigma_hat3, parm_res_fix_sigma_hat[[3]]$Omega_array[3, 3, ])
}
```

```{r}
true_Omega[1, 1]
true_Omega[2, 2]
true_Omega[3, 3]
```


```{r}
for (i in 1:length(g_val_list)) {
  g_val_i = g_val_list[i]
  traceplot_list = mcmc.list(as.mcmc(ll_l_sigma_hat1[i, (n_burn + 1):n_iter]), as.mcmc(ll_l_sigma_hat2[i, (n_burn + 1):n_iter]), as.mcmc(ll_l_sigma_hat3[i, (n_burn + 1):n_iter]))
  par(mar = c(2, 2, 2, 2))
  traceplot(traceplot_list, main = paste("Log-likelihood traceplot with true Omega g =", g_val_i))
  abline(h = true_ll_trn, col = "orange")
  legend("right", legend=c("Omega standard normal", "Omega normal variance 100", "true Omega"),  
         fill = c("black","red", "green"))
  
  Omega_11_traceplot_list = mcmc.list(as.mcmc(Omega_11_sigma_hat1[i, ]), as.mcmc(Omega_11_sigma_hat2[i, ]), as.mcmc(Omega_11_sigma_hat3[i, ]))
  traceplot(Omega_11_traceplot_list, main = paste("Omega 11 traceplot with sigma hat g =", g_val_i))
  abline(h = true_Omega[1, 1], col = "orange")
  legend("bottomright", legend=c("Omega 11 standard normal", "Omega 11 normal variance 100", "true Omega 11"),  
         fill = c("black","red", "green"))
  
  Omega_22_traceplot_list = mcmc.list(as.mcmc(Omega_22_sigma_hat1[i, ]), as.mcmc(Omega_22_sigma_hat2[i, ]), as.mcmc(Omega_22_sigma_hat3[i, ]))
  traceplot(Omega_22_traceplot_list, main = paste("Omega 22 traceplot with sigma hat g =", g_val_i))
  abline(h = true_Omega[2, 2], col = "orange")
  legend("bottomright", legend=c("Omega 22 standard normal", "Omega 22 normal variance 100", "true Omega 22"),  
         fill = c("black","red", "green"))
  
  Omega_33_traceplot_list = mcmc.list(as.mcmc(Omega_33_sigma_hat1[i, ]), as.mcmc(Omega_33_sigma_hat2[i, ]), as.mcmc(Omega_33_sigma_hat3[i, ]))
  traceplot(Omega_33_traceplot_list, main = paste("Omega 33 traceplot with true sigma hat g =", g_val_i))
  abline(h = true_Omega[3, 3], col = "orange")
  legend("bottomright", legend=c("Omega 33 standard normal", "Omega 33 normal variance 100", "true Omega 33"),  
         fill = c("black","red", "green"))
  
}
```




```{r, cache = TRUE}
ll_l_both1 = c()
Omega_11_both1 = c()
Omega_22_both1 = c()
Omega_33_both1 = c()
sigma_both1 = c()
ll_l_both2 = c()
Omega_11_both2 = c()
Omega_22_both2 = c()
Omega_33_both2 = c()
sigma_both2 = c()
ll_l_both3 = c()
Omega_11_both3 = c()
Omega_22_both3 = c()
Omega_33_both3 = c()
sigma_both3 = c()
n_iter = 10000
n_burn = 7500
for (g_hyper in g_val_list) {
  parm_res_both = parm_gen_qr_12(X_trn, basis_X, Omega_initial, basis_Z, Z_trn, sigma_e_initial, a_initial,n_iter, n_burn, true_gamma_p, pred_nmb, latent_nmb, A, g = g_hyper)
  ll_l_both1 = rbind(ll_l_both1, parm_res_both[[1]]$ll_l)
  ll_l_both2 = rbind(ll_l_both2, parm_res_both[[2]]$ll_l)
  ll_l_both3 = rbind(ll_l_both3, parm_res_both[[3]]$ll_l)
  
  Omega_11_both1 = rbind(Omega_11_both1, parm_res_both[[1]]$Omega_array[1, 1, ])
  Omega_22_both1 = rbind(Omega_22_both1, parm_res_both[[1]]$Omega_array[2, 2, ])
  Omega_33_both1 = rbind(Omega_33_both1, parm_res_both[[1]]$Omega_array[3, 3, ])
  sigma_both1 = rbind(sigma_both1, parm_res_both[[1]]$sigma_e)

  Omega_11_both2 = rbind(Omega_11_both2, parm_res_both[[2]]$Omega_array[1, 1, ])
  Omega_22_both2 = rbind(Omega_22_both2, parm_res_both[[2]]$Omega_array[2, 2, ])
  Omega_33_both2 = rbind(Omega_33_both2, parm_res_both[[2]]$Omega_array[3, 3, ])
  sigma_both2 = rbind(sigma_both2, parm_res_both[[2]]$sigma_e)
  
  Omega_11_both3 = rbind(Omega_11_both3, parm_res_both[[3]]$Omega_array[1, 1, ])
  Omega_22_both3 = rbind(Omega_22_both3, parm_res_both[[3]]$Omega_array[2, 2, ])
  Omega_33_both3 = rbind(Omega_33_both3, parm_res_both[[3]]$Omega_array[3, 3, ])
  sigma_both3 = rbind(sigma_both3, parm_res_both[[3]]$sigma_e)
}
```

```{r}
for (i in 1:length(g_val_list)) {
  g_val_i = g_val_list[i]
  traceplot_list = mcmc.list(as.mcmc(ll_l_both1[i, (n_burn + 1):n_iter]), as.mcmc(ll_l_both2[i, (n_burn + 1):n_iter]), as.mcmc(ll_l_both3[i, (n_burn + 1):n_iter]))
  par(mar = c(2, 2, 2, 2))
  traceplot(traceplot_list, main = paste("Log-likelihood traceplot both =", g_val_i))
  abline(h = true_ll_trn, col = "orange")
  legend("right", legend=c("Omega standard normal", "Omega normal variance 100", "true Omega"),  
         fill = c("black","red", "green"))
  Omega_11_traceplot_list = mcmc.list(as.mcmc(Omega_11_both1[i, ]), as.mcmc(Omega_11_both2[i, ]), as.mcmc(Omega_11_both3[i, ]))
  traceplot(Omega_11_traceplot_list, main = paste("Omega 11 traceplot g =", g_val_i))
  legend("bottomright", legend=c("Omega 11 standard normal", "Omega 11 normal variance 100", "true Omega 11"),  
         fill = c("black","red", "green"))
  abline(h = true_Omega[1, 1], col = "orange")
  Omega_22_traceplot_list = mcmc.list(as.mcmc(Omega_22_both1[i, ]), as.mcmc(Omega_22_both2[i, ]), as.mcmc(Omega_22_both3[i, ]))
  traceplot(Omega_22_traceplot_list, main = paste("Omega 22 traceplot g =", g_val_i))
  legend("bottomright", legend=c("Omega 22 standard normal", "Omega 22 normal variance 100", "true Omega 22"),  
         fill = c("black","red", "green"))
  abline(h = true_Omega[2, 2], col = "orange")
  Omega_33_traceplot_list = mcmc.list(as.mcmc(Omega_33_both1[i, ]), as.mcmc(Omega_33_both2[i, ]), as.mcmc(Omega_33_both3[i, ]))
  traceplot(Omega_33_traceplot_list, main = paste("Omega 33 traceplot g =", g_val_i))
  legend("bottomright", legend=c("Omega 33 standard normal", "Omega 33 normal variance 100", "true Omega 33"),  
         fill = c("black","red", "green"))
  abline(h = true_Omega[3, 3], col = "orange")
  sigma_traceplot_list = mcmc.list(as.mcmc(sigma_both1[i, ]), as.mcmc(sigma_both2[i, ]), as.mcmc(sigma_both3[i, ]))
  traceplot(sigma_traceplot_list, main = paste("sigma traceplot g =", g_val_i))
  legend("bottomright", legend=c("sigma = 1.5", "sigma = 1", "sigma = 0.5"),  
         fill = c("black","red", "green"))
  abline(h = true_sigma_e, col = "orange")
}
```


```{r, eval = FALSE}
Z_star_no_iter_list = Z_star_no_iter(Z_trn, basis_Z)
bz2 = Z_star_no_iter_list$bz2
R_bz = Z_star_no_iter_list$R_bz
Z_star_b = Z_star_no_iter_list$Z_star
# This part will be iteratively changed if the gamma p sampled
X_tilde = weighted_pred(X_trn, true_gamma_p, pred_nmb)
Z_star_list = Z_star_gen(Z_bz, X_tilde, basis_X, Z_star_b)
Z_star_iter = Z_star_list$Z_star_iter
bx_x_x_bx = Z_star_list$bx_x_x_bx
trace_val = sum(diag(bz2 %*% crossprod(Z_star_iter, bx_x_x_bx) %*% Z_star_iter))
A = 1
I_g = function(g, A, trace_val, basis_X, basis_Z) {
  Mz = nrow(basis_Z)
  Mx = nrow(basis_X)
  C =  -0.5 * trace_val / (g + 1)
  integrand = function(sigma_e2) {
    exp_term <- exp(C / sigma_e2)
    sigma_mm = (sigma_e2)^(-Mz * Mx / 2)
    half_cau = A^2 / (A^2 + sigma_e2)
    half_cau * sigma_mm * exp_term
  }
  integrate(integrand, lower = 1e-6, upper = 1e15, subdivisions = 1000)$value
}
object_func = function(g, A, basis_X, basis_Z, trace_val) {
  Mz = nrow(basis_Z)
  Mx = nrow(basis_X)
  I_g_val = I_g(g, A, trace_val, basis_X, basis_Z)
  -Mx * Mz * 0.5 * log(g) + log(I_g_val)
}
optim_g = optim(par = 1e5, fn = function(g) -object_func(g, A, basis_X, basis_Z, trace_val), method = "BFGS")
```

